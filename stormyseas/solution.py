from typing import List, Dict

from stormyseas.directions import Cardinal
from stormyseas.move import Move
from stormyseas.pieces import Boat
from stormyseas.state import State


class Solution:
    def __init__(self, moves: List[Move]):
        self._moves = moves

    def step_count(self) -> int:
        """A step is a move of any distance."""
        return len(self._moves)

    def move_count(self) -> int:
        """A move is the act of moving a piece in a direction by one space."""
        return sum(move.distance for move in self._moves)

    def __str__(self) -> str:
        return ', '.join(str(move) for move in self._moves)


class MoveGenerator:
    def __init__(self, initial_state: State, final_state: State, state_map: Dict[State, Move]):
        self.initial_state = initial_state
        self.final_state = final_state
        self.state_map = state_map

    def generate(self) -> List[Move]:
        """Generates a list of moves by traversing from the final state to the initial state using the state
        map generated by StateSearch.
        """
        # Every solution will need a final step of XD2 since our Puzzle.PORT position is adjusted to be in bounds.
        moves = [Move(Boat.RED_BOAT_ID, Cardinal.DOWN, 2)]

        current_state = self.final_state

        while current_state != self.initial_state:
            previous_move = self.state_map[current_state]

            if len(moves) > 0 and moves[0].can_merge_with(previous_move):
                moves[0].merge(previous_move)
            else:
                moves.insert(0, previous_move)

            piece = current_state.find_piece(previous_move.piece_id)
            current_state = current_state.undo(piece, previous_move.direction)

        return moves
